01 - Setup TypeORM for connecting database in NestJS
    Step 01: Installation
        Install the npm package:

        npm install typeorm --save

        You need to install reflect-metadata shim:

        npm install reflect-metadata --save

        and import it somewhere in the global place of your app (for example in app.ts):

        import "reflect-metadata"

        You may need to install node typings:

        npm install @types/node --save-dev

        Install the db lib for data (used):
            for MySQL or MariaDB

            npm install mysql --save (you can install mysql2 instead as well)

            for PostgreSQL or CockroachDB

            npm install pg --save

            for SQLite

            npm install sqlite3 --save

            for Microsoft SQL Server

            npm install mssql --save

            for sql.js

            npm install sql.js --save

            for Oracle

            npm install oracledb --save

            To make the Oracle driver work, you need to follow the installation instructions from their site.

            for SAP Hana

            npm install @sap/hana-client
            npm install hdb-pool
            SAP Hana support made possible by the sponsorship of Neptune Software.

            for Google Cloud Spanner

            npm install @google-cloud/spanner --save
            Provide authentication credentials to your application code by setting the environment variable GOOGLE_APPLICATION_CREDENTIALS:

            # Linux/macOS
            export GOOGLE_APPLICATION_CREDENTIALS="KEY_PATH"

            # Windows
            set GOOGLE_APPLICATION_CREDENTIALS=KEY_PATH

            # Replace KEY_PATH with the path of the JSON file that contains your service account key.
            To use Spanner with the emulator you should set SPANNER_EMULATOR_HOST environment variable:

            # Linux/macOS
            export SPANNER_EMULATOR_HOST=localhost:9010

            # Windows
            set SPANNER_EMULATOR_HOST=localhost:9010
            for MongoDB (experimental)

            npm install mongodb@^5.2.0 --save

            for NativeScript, react-native and Cordova

            Check documentation of supported platforms

02. Install lib for type orm: $ npm install --save @nestjs/typeorm typeorm

03. Config datasource for connecting db:
    a. Create class data-source.ts:
        import {
            DataSource, DataSourceOptions
        } from 'typeorm'

        import {config} from 'dotenv'

        config();

        export const dataSourceOption:DataSourceOptions={
            type: 'postgres',
            host: process.env.DB_HOST,
            port: Number(process.env.DB_PORT),
            username: process.env.DB_USERNAME,
            password: process.env.DB_PASSWORD,
            entities: [

            ],
            migrations: [

            ],
            logging: false,
            synchronize: false,
        }

        const dataSource = new DataSource(dataSourceOption);

        export default dataSource;

04. Import data-source config on app.moudle.ts for using datasource connection
    // src/app.module.ts
    ....
    import { TypeOrmModule } from '@nestjs/typeorm';
    import { dataSourceOption } from 'db/datas-source';

    imports: [
        /**
        * Import type orm with datasoruce connected with db (datas-source.ts) for connecting database
        */
        TypeOrmModule.forRoot(dataSourceOption),
    ],
    ....

After that, run command line: npm run start:dev for testing datasource connection.
-----------------------------------------------------------------------------------------------------
List Entities in this project:
    Users
    Products
    orders
    shipping info
    category
-----------------------------------------------------------------------------------------------------
Some command-line for creating crud action in NestJs:
CRUD generator
Throughout the life span of a project, when we build new features, we often need to add new resources to our application. These resources typically require multiple, repetitive operations that we have to repeat each time we define a new resource.

Introduction#
Let's imagine a real-world scenario, where we need to expose CRUD endpoints for 2 entities, let's say User and Product entities. Following the best practices, for each entity we would have to perform several operations, as follows:

Generate a module (nest g mo) to keep code organized and establish clear boundaries (grouping related components)
Generate a controller (nest g co) to define CRUD routes (or queries/mutations for GraphQL applications)
Generate a service (nest g s) to implement & isolate business logic
Generate an entity class/interface to represent the resource data shape
Generate Data Transfer Objects (or inputs for GraphQL applications) to define how the data will be sent over the network
That's a lot of steps!

To help speed up this repetitive process, Nest CLI provides a generator (schematic) that automatically generates all the boilerplate code to help us avoid doing all of this, and make the developer experience much simpler.

NOTE
The schematic supports generating HTTP controllers, Microservice controllers, GraphQL resolvers (both code first and schema first), and WebSocket Gateways.
Generating a new resource#
To create a new resource, simply run the following command in the root directory of your project:


$ nest g resource

-----------------------------------------------------------------------------------------------------

02. Basic create and use entity in NestJs:
    01. Create entity-class: UserEntity in user.entity.ts

    import { Roles } from "src/utility/common/user-roles.enum";
    import { Column, Entity, PrimaryGeneratedColumn } from "typeorm";

    @Entity("users")
    export class UserEntity {
        @PrimaryGeneratedColumn()
        id: number;

        @Column()
        name: string;

        @Column()
        email: string;

        @Column()
        password: string;

        @Column({
            type: 'enum',
            enum: Roles,
            array: true,
            default: [
                Roles.USER
            ]
        })
        roles: Roles[]
    }

    02. Import in this *.moudule.ts of this resource for using entity on this:
        ...
        import { TypeOrmModule } from '@nestjs/typeorm';
        import { UserEntity } from './entities/user.entity';

        ...
        imports: [
            /**
            * import UserEntity for using this entity on this resource
            */
            TypeOrmModule.forFeature([UserEntity])
        ],
        ...

------------------------------------------------------------------------------------------------------------------------
03. Setup Migration in Nestjs project by TypeOrm:
    01. Config migration file of data-source.ts
        ....
        entities: [
            'dist/**/*.entity{.ts,.js}',
        ],
        migrations: [
            'dist/db/migrations/*{.ts,.js}'
        ],
        ....
    
    02. setting synchronize: false beacause of limiting refresh or create entities after running and executing app

    03. In this project, add syntax running command for migration db in package.json:
    "migration:generate":"npm run typeorm -- migration:generate",
    "migration:run":"npm run typeorm -- migration:run",
    "migration-revert":"npm run typeorm -- migration:revert",
    "db:drop":"npm run typeorm schema:drop"

    Arrange Running:
        npm run db:drop (for dropping old database) -- optional
        1. npm run migration:generate -- pathFileMigration (for generating migration file)
            ex: npm run migration:generate -- db/migrations/initial
        2. npm run migration:run (for executing migration and create object in db)

-------------------------------------------------------------------------------------------------
Using Repository pattern for handling function:
With that in place, we can inject the UsersRepository into the UsersService using the @InjectRepository() decorator:

-------------------------------------------------------------------------------------------------
05. Validation
    01. Installation
        we'll focus on various real world use cases of the ValidationPipe, and show how to use some of its advanced customization features.

        Using the built-in ValidationPipe#
        To begin using it, we first install the required dependency.


        $ npm i --save class-validator class-transformer

    02. Setup on root file of project:
        // src/main.tsx
        ....
        app.useGlobalPipes(new ValidationPipe());
        ....

    03. Using in class object for validation:
        ex:
            import { IsEmail, IsNotEmpty } from 'class-validator';

            export class CreateUserDto {
            @IsEmail()
            email: string;

            @IsNotEmpty()
            password: string;
            }

------------------------------------------------------------------------------------------------------------------------
Middleware
Middleware is a function which is called before the route handler. Middleware functions have access to the request and response objects, and the next() middleware function in the applicationâ€™s request-response cycle. The next middleware function is commonly denoted by a variable named next.

Export UserService for using userRepository for getting user by id:
    // src/users/user.moudle.ts
    ....
    exports: [
        UsersService,
    ]
    ....

Basic implement Middleware for getting current user by authId:
    interface JwtPayload {
        id: string;
    }

    declare global {
        namespace Express {
            interface Request {
                currentUser?: UserEntity;
            }
        }
    }

    @Injectable()
    export class CurrentUserMiddleWare implements NestMiddleware {
        
        /**
        *
        */
        constructor(private readonly userService: UsersService) {
            
        }

        async use(req: Request, res: Response, next: NextFunction) {
        // console.log(req);

        const authHeader = req.headers.authorization || req.headers.Authorization;

        if (!authHeader || isArray(authHeader) || !authHeader.startsWith('Bearer ')) {
            req.currentUser = null;
            next();
        } else {
            const token = authHeader.split(' ')[1];
            console.log(token);
            const {
                id
            } = <JwtPayload>verify(token, process.env.ACCESS_TOKEN_SECRET_KEY);

            const currentUser = await this.userService.findOne(+id);
            console.log(currentUser);
            req.currentUser = currentUser;
            next();
        }
    }
    }

    Basic config middleware in app.module.ts:
        export class AppModule implements NestModule {
            configure(consumer: MiddlewareConsumer) {
                consumer
                .apply(CurrentUserMiddleWare)
                .forRoutes({ path: '*', method: RequestMethod.ALL });
            }

        }

    


------------------------------------------------------------------------------------------------------------------------
Custom route decorators
Nest is built around a language feature called decorators. Decorators are a well-known concept in a lot of commonly used programming languages, but in the JavaScript world, they're still relatively new. In order to better understand how decorators work, we recommend reading this article. Here's a simple definition:

In this project custom decorator for getting current user:
    01. Create decoractor for getting currentUser from Request (Request is set on the middleware step).
        import { createParamDecorator, ExecutionContext } from '@nestjs/common';

        export const CurrentUserDecorator = createParamDecorator(
            (data: never, ctx: ExecutionContext) => {
                const request = ctx.switchToHttp().getRequest();
                return request.currentUser;
            },
        );

Using CurrentUserDecorator in UserController for getting currentUser on request:
    @Get('me')
    getProfile(@CurrentUserDecorator() currentUser: UserEntity) {
        return currentUser;
    }

-------------------------------------------------------------------------------
Guards
A guard is a class annotated with the @Injectable() decorator, which implements the CanActivate interface.

Guards have a single responsibility. They determine whether a given request will be handled by the route handler or not, depending on certain conditions (like permissions, roles, ACLs, etc.) present at run-time. This is often referred to as authorization. Authorization (and its cousin, authentication, with which it usually collaborates) has typically been handled by middleware in traditional Express applications. Middleware is a fine choice for authentication, since things like token validation and attaching properties to the request object are not strongly connected with a particular route context (and its metadata).

