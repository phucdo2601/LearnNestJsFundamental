01 - Setup TypeORM for connecting database in NestJS
    Step 01: Installation
        Install the npm package:

        npm install typeorm --save

        You need to install reflect-metadata shim:

        npm install reflect-metadata --save

        and import it somewhere in the global place of your app (for example in app.ts):

        import "reflect-metadata"

        You may need to install node typings:

        npm install @types/node --save-dev

        Install the db lib for data (used):
            for MySQL or MariaDB

            npm install mysql --save (you can install mysql2 instead as well)

            for PostgreSQL or CockroachDB

            npm install pg --save

            for SQLite

            npm install sqlite3 --save

            for Microsoft SQL Server

            npm install mssql --save

            for sql.js

            npm install sql.js --save

            for Oracle

            npm install oracledb --save

            To make the Oracle driver work, you need to follow the installation instructions from their site.

            for SAP Hana

            npm install @sap/hana-client
            npm install hdb-pool
            SAP Hana support made possible by the sponsorship of Neptune Software.

            for Google Cloud Spanner

            npm install @google-cloud/spanner --save
            Provide authentication credentials to your application code by setting the environment variable GOOGLE_APPLICATION_CREDENTIALS:

            # Linux/macOS
            export GOOGLE_APPLICATION_CREDENTIALS="KEY_PATH"

            # Windows
            set GOOGLE_APPLICATION_CREDENTIALS=KEY_PATH

            # Replace KEY_PATH with the path of the JSON file that contains your service account key.
            To use Spanner with the emulator you should set SPANNER_EMULATOR_HOST environment variable:

            # Linux/macOS
            export SPANNER_EMULATOR_HOST=localhost:9010

            # Windows
            set SPANNER_EMULATOR_HOST=localhost:9010
            for MongoDB (experimental)

            npm install mongodb@^5.2.0 --save

            for NativeScript, react-native and Cordova

            Check documentation of supported platforms

02. Install lib for type orm: $ npm install --save @nestjs/typeorm typeorm

03. Config datasource for connecting db:
    a. Create class data-source.ts:
        import {
            DataSource, DataSourceOptions
        } from 'typeorm'

        import {config} from 'dotenv'

        config();

        export const dataSourceOption:DataSourceOptions={
            type: 'postgres',
            host: process.env.DB_HOST,
            port: Number(process.env.DB_PORT),
            username: process.env.DB_USERNAME,
            password: process.env.DB_PASSWORD,
            entities: [

            ],
            migrations: [

            ],
            logging: false,
            synchronize: false,
        }

        const dataSource = new DataSource(dataSourceOption);

        export default dataSource;

04. Import data-source config on app.moudle.ts for using datasource connection
    // src/app.module.ts
    ....
    import { TypeOrmModule } from '@nestjs/typeorm';
    import { dataSourceOption } from 'db/datas-source';

    imports: [
        /**
        * Import type orm with datasoruce connected with db (datas-source.ts) for connecting database
        */
        TypeOrmModule.forRoot(dataSourceOption),
    ],
    ....

After that, run command line: npm run start:dev for testing datasource connection.
-----------------------------------------------------------------------------------------------------
List Entities in this project:
    Users
    Products
    orders
    shipping info
    category
-----------------------------------------------------------------------------------------------------
Some command-line for creating crud action in NestJs:
CRUD generator
Throughout the life span of a project, when we build new features, we often need to add new resources to our application. These resources typically require multiple, repetitive operations that we have to repeat each time we define a new resource.

Introduction#
Let's imagine a real-world scenario, where we need to expose CRUD endpoints for 2 entities, let's say User and Product entities. Following the best practices, for each entity we would have to perform several operations, as follows:

Generate a module (nest g mo) to keep code organized and establish clear boundaries (grouping related components)
Generate a controller (nest g co) to define CRUD routes (or queries/mutations for GraphQL applications)
Generate a service (nest g s) to implement & isolate business logic
Generate an entity class/interface to represent the resource data shape
Generate Data Transfer Objects (or inputs for GraphQL applications) to define how the data will be sent over the network
That's a lot of steps!

To help speed up this repetitive process, Nest CLI provides a generator (schematic) that automatically generates all the boilerplate code to help us avoid doing all of this, and make the developer experience much simpler.

NOTE
The schematic supports generating HTTP controllers, Microservice controllers, GraphQL resolvers (both code first and schema first), and WebSocket Gateways.
Generating a new resource#
To create a new resource, simply run the following command in the root directory of your project:


$ nest g resource

-----------------------------------------------------------------------------------------------------

02. Basic create and use entity in NestJs:
    01. Create entity-class: UserEntity in user.entity.ts

    import { Roles } from "src/utility/common/user-roles.enum";
    import { Column, Entity, PrimaryGeneratedColumn } from "typeorm";

    @Entity("users")
    export class UserEntity {
        @PrimaryGeneratedColumn()
        id: number;

        @Column()
        name: string;

        @Column()
        email: string;

        @Column()
        password: string;

        @Column({
            type: 'enum',
            enum: Roles,
            array: true,
            default: [
                Roles.USER
            ]
        })
        roles: Roles[]
    }

    02. Import in this *.moudule.ts of this resource for using entity on this:
        ...
        import { TypeOrmModule } from '@nestjs/typeorm';
        import { UserEntity } from './entities/user.entity';

        ...
        imports: [
            /**
            * import UserEntity for using this entity on this resource
            */
            TypeOrmModule.forFeature([UserEntity])
        ],
        ...

------------------------------------------------------------------------------------------------------------------------
03. Setup Migration in Nestjs project by TypeOrm:
    01. Config migration file of data-source.ts
        ....
        entities: [
            'dist/**/*.entity{.ts,.js}',
        ],
        migrations: [
            'dist/db/migrations/*{.ts,.js}'
        ],
        ....
    
    02. setting synchronize: false beacause of limiting refresh or create entities after running and executing app

    03. In this project, add syntax running command for migration db in package.json:
    "migration:generate":"npm run typeorm -- migration:generate",
    "migration:run":"npm run typeorm -- migration:run",
    "migration-revert":"npm run typeorm -- migration:revert",
    "db:drop":"npm run typeorm schema:drop"

    Arrange Running:
        npm run db:drop (for dropping old database) -- optional
        1. npm run migration:generate -- pathFileMigration (for generating migration file)
            ex: npm run migration:generate -- db/migrations/initial
        2. npm run migration:run (for executing migration and create object in db)

-------------------------------------------------------------------------------------------------
Using Repository pattern for handling function:
With that in place, we can inject the UsersRepository into the UsersService using the @InjectRepository() decorator: